# hhplus_traffic_control_task_01

## 동시성 문제가 생길 수 있는 메소드

목록 불러오기 같은 데이터는 정합성이 맞을 수가 없다. 받아서 사용자에게 바로 보여준다 해도, 바로바로 데이터가 변할 수 있기 때문이다. 그렇게에 모든 데이터에 LOCK을 사용하진 않는다.

### 콘서트 결제(`PayConcertUseCase`)

```java
public ConcertApplyHistory execute(ConcertRequestDto concertRequestDto){
    
    // 공연 정보 찾아오기

    // 사용자(포인트) 정보 찾아오기

    // 포인트가 적절히 있는지 확인하기
    if(concert.getCharge() > userPoint.getPoint())
        throw new CustomRuntimeException("보유하신 포인트가 부족합니다.");

    // 포인트 사용하기

    // return 관련정보 반환하기
}
```

#### 공연 정보 찾아오기

락을 사용하지 않는다.

해당 메소드에서 필요한 부분은 공연의 가격이나, 사용자들이 공연을 결제 중에 공연의 금액이 변하는 경우는 없다고 상정한다.

#### 사용자(포인트) 정보 찾아오기

별도의 락을 필요로 하지 않는다.

#### 포인트 사용

비관적 락을 이용한다.

해당 데이터에 사람이 몰릴 가능성은 한 사용자가 악의적으로 1회분의 포인트로 두개 이상의 공연을 결제 할 때 발생할 수 있다.

해당 데이터는 충동 가능성은 낮지만, 정합성이 중요한 편이고, 낙관적으로 롤백 후 계속 결제를 진행하기 어렵다고 판단 된다.

#### 공연 결제

ConcertApplyHistory는 예약이 된 사용자라고 할지라도 결제 중 예약된 시간이 지나, 그 사이 다른 사용자가 예약을 할 수도 있다.

해당 부분은 비관적 락을 이용한다.
트랜잭션의 많은 충돌이 예상되는 기능이다.

서비스에서의 중요도도 높다고 판단되며, 쓰기락(배타락)을 이용해서 락을 얻으면 다른 사용자가 읽거나 쓰지 못하게 하여 결제를 방어한다.

다른 사용자가 읽지 못한다면, 다른 쓰레드에서 진행할 수 없기에 완전히 방어 할 수 있다.

### 콘서트 예약 (`ReserveConcertUseCase`)

```java
public ConcertApplyHistory execute(ConcertRequestDto concertRequestDto){
    // 예약처리 및 결과 반환
}
```

#### 공연 예약 처리

해당 공연을 쓰기락을 이용해서 정합성을 맞춘다. 이유는 결제와 같다.

### 포인트 충전/사용 (`ChangePointUseCase`)

비관적 락으로 관리한다.

충전과 사용은 트래픽이 생기는 기능은 아니지만, 정합성의 중요도가 매우 높고, 사용과 충전의 순서 역시 중요하다.

그래서 비관적 배타락을 사용한다.

## 정리

결과적으로 해당 과제에선 비관적 락을 전체적으로 사용할 예정이다.

다만 사용하는 이유는 각각의 다른 이유가 있다.

- 정합성이 매우 중요한 데이터
- 낙관적으로 실행해서 retry하기 곤란한 데이터
- 트레픽이 매우 몰릴것으로 예상되는 데이터
 
위의 각각의 이유로 낙관적락이 사용되기 힘들다고 생각했다.
